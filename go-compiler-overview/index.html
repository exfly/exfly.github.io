<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Go Overview - ExflyBlog</title><meta name="Description" content="ExflyBlog, IT technology sharing, technology blog"><meta property="og:title" content="Go Overview" />
<meta property="og:description" content="文章简介：golang 各种元素整理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://exfly.github.io/go-compiler-overview/" /><meta property="og:image" content="https://exfly.github.io/media/img/avatar.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-06T08:57:31+08:00" />
<meta property="article:modified_time" content="2023-01-27T21:51:00+08:00" /><meta property="og:site_name" content="ExflyBlog" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://exfly.github.io/media/img/avatar.jpg" /><meta name="twitter:title" content="Go Overview"/>
<meta name="twitter:description" content="文章简介：golang 各种元素整理"/>
<meta name="application-name" content="Exfly">
<meta name="apple-mobile-web-app-title" content="Exfly"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://exfly.github.io/go-compiler-overview/" /><link rel="prev" href="https://exfly.github.io/opentracing-jaeger-agent-src-code-introduce/" /><link rel="next" href="https://exfly.github.io/go-runtime-fatal-sigsegv-during-c.getaddrinfo/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Go Overview",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/exfly.github.io\/go-compiler-overview\/"
        },"image": ["https:\/\/exfly.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","wordcount":  3544 ,
        "url": "https:\/\/exfly.github.io\/go-compiler-overview\/","datePublished": "2020-05-06T08:57:31+08:00","dateModified": "2023-01-27T21:51:00+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/exfly.github.io\/media\/img\/avatar.jpg"},"author": {
                "@type": "Person",
                "name": "Exfly"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="ExflyBlog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span>ExflyBlog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/exfly" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><a class="menu-item" href="/about/" title="关于"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a><a href="javascript:void(0);" class="menu-item language" title="选择语言">
                    <i class="fa fa-globe" aria-hidden="true"></i>                      
                    <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/go-compiler-overview/" selected>简体中文</option></select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="ExflyBlog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span>ExflyBlog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/exfly" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a class="menu-item" href="/about/" title="关于">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="选择语言">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/go-compiler-overview/" selected>简体中文</option></select>
                </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Go Overview</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/exfly/" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Exfly</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2020-05-06">2020-05-06</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 3544 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 8 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#编译原理">编译原理</a>
      <ul>
        <li><a href="#编译器入口-srccmdcompileinternalgcmaingohttpsgithubcomgolanggoblobmastersrccmdcompileinternalgcmaingo">编译器入口 <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go">src/cmd/compile/internal/gc/main.go</a></a></li>
        <li><a href="#技巧">技巧</a></li>
      </ul>
    </li>
    <li><a href="#plan9">plan9</a></li>
    <li><a href="#基本数据结构">基本数据结构</a>
      <ul>
        <li><a href="#数组">数组</a></li>
        <li><a href="#切片">切片</a>
          <ul>
            <li><a href="#make">make</a></li>
            <li><a href="#append">append</a></li>
          </ul>
        </li>
        <li><a href="#哈希表">哈希表</a>
          <ul>
            <li><a href="#哈希函数">哈希函数</a></li>
            <li><a href="#冲突解决方法">冲突解决方法</a></li>
          </ul>
        </li>
        <li><a href="#字符串">字符串</a></li>
      </ul>
    </li>
    <li><a href="#oo">OO</a>
      <ul>
        <li><a href="#函数调用">函数调用</a>
          <ul>
            <li><a href="#参数传递">参数传递</a></li>
          </ul>
        </li>
        <li><a href="#接口">接口</a></li>
        <li><a href="#反射">反射</a></li>
      </ul>
    </li>
    <li><a href="#常用关键字">常用关键字</a>
      <ul>
        <li><a href="#for-和-range">for 和 range</a></li>
        <li><a href="#select">select</a></li>
        <li><a href="#defer">defer</a></li>
        <li><a href="#panic-和-recover">panic 和 recover</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#make-和-new">make 和 new</a></li>
      </ul>
    </li>
    <li><a href="#运行时">运行时</a>
      <ul>
        <li><a href="#并发">并发</a>
          <ul>
            <li><a href="#上下文-context">上下文 Context</a></li>
            <li><a href="#同步原语与锁">同步原语与锁</a></li>
            <li><a href="#定时器">定时器</a></li>
            <li><a href="#channel">Channel</a></li>
            <li><a href="#调度器">调度器</a></li>
            <li><a href="#网络轮询器">网络轮询器</a></li>
            <li><a href="#系统监控">系统监控</a></li>
          </ul>
        </li>
        <li><a href="#内存管理">内存管理</a>
          <ul>
            <li><a href="#内存分配器">内存分配器</a></li>
            <li><a href="#垃圾收集器">垃圾收集器</a></li>
            <li><a href="#栈内存管理">栈内存管理</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#其他">其他</a>
      <ul>
        <li><a href="#unsafe">unsafe</a></li>
        <li><a href="#逃逸分析">逃逸分析</a></li>
      </ul>
    </li>
    <li><a href="#build-comment">build comment</a></li>
    <li><a href="#reference">reference</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>文章简介：golang 各种元素整理</p>
<h2 id="编译原理">编译原理</h2>
<blockquote>
<p>比较好的介绍 golang 的编译器看 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/" target="_blank" rel="noopener noreffer ">这里</a></p>
</blockquote>
<p>代码中对 <code>go compiler</code> 的描述: <a href="https://github.com/golang/go/blob/master/src/cmd/compile/README.md" target="_blank" rel="noopener noreffer ">src/cmd/compile/README.md</a></p>
<p>what is ssa: <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="noopener noreffer ">wiki</a> IR</p>
<p>golang Static Single Assignment: <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/README.md" target="_blank" rel="noopener noreffer ">src/cmd/compile/internal/ssa/README.md</a></p>
<h3 id="编译器入口-srccmdcompileinternalgcmaingohttpsgithubcomgolanggoblobmastersrccmdcompileinternalgcmaingo">编译器入口 <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go" target="_blank" rel="noopener noreffer ">src/cmd/compile/internal/gc/main.go</a></h3>
<h3 id="技巧">技巧</h3>
<ul>
<li>生成 SSA 整个过程结果展示(html): GOSSAFUNC=hello go build hello/hello.go</li>
<li>生成 plan9 汇编代码 GOOS=linux GOARCH=amd64 go tool compile -S hello/hello.go</li>
</ul>
<p>TODO: 给一个例子，并解释一下(需要了解所有步骤)</p>
<h2 id="plan9">plan9</h2>
<h2 id="基本数据结构">基本数据结构</h2>
<h3 id="数组">数组</h3>
<p><a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L875-L967" target="_blank" rel="noopener noreffer ">https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L875-L967</a></p>
<p>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；
当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</p>
<p>无论是在栈上还是静态存储区，数组在内存中其实就是一连串的内存空间，表示数组的方法就是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型占的空间大小</p>
<p>Go 语言中对数组越界的判断是可以在编译期间由静态类型检查完成的 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2081" target="_blank" rel="noopener noreffer ">https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2081</a></p>
<h3 id="切片">切片</h3>
<blockquote>
<p><a href="https://blog.golang.org/slices-intro" target="_blank" rel="noopener noreffer ">图解 slice</a></p>
</blockquote>
<p><a href="https://github.com/golang/go/blob/616c39f6a636166447bdaac4f0871a5ca52bae8c/src/cmd/compile/internal/types/type.go#L484-L496" target="_blank" rel="noopener noreffer ">NewSlice</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// [slice](https://github.com/golang/go/blob/4c003f6b780b471afbf032438eb6c7519458855b/src/reflect/value.go#L1973)
</span></span><span class="line"><span class="cl">type SliceHeader struct {
</span></span><span class="line"><span class="cl">	Data uintptr
</span></span><span class="line"><span class="cl">	Len  int
</span></span><span class="line"><span class="cl">	Cap  int
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">slice := []int{1, 2, 3}
</span></span><span class="line"><span class="cl">slice := make([]int, 10)
</span></span></code></pre></td></tr></table>
</div>
</div><p>[:], a slice referencing the storage of x</p>
<blockquote>
<p>[:] 操作是创建切片最底层的一种方法</p>
</blockquote>
<h4 id="make">make</h4>
<p><a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2126" target="_blank" rel="noopener noreffer ">make 关键词</a></p>
<p>当切片发生逃逸或者非常大时，我们需要 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="noopener noreffer ">runtime.makeslice</a> 函数在堆上初始化，
如果当前的切片不会发生逃逸并且切片非常小的时候，make([]int, 3, 4) 会被直接转换成如下所示的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">var</span> <span class="n">arr</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="p">:</span><span class="o">=</span> <span class="n">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/golang/go/commit/020a18c545bf49ffc087ca93cd238195d8dcc411" target="_blank" rel="noopener noreffer ">golang 对 slice 比较有意义的优化</a></p>
<h4 id="append">append</h4>
<p><a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191" target="_blank" rel="noopener noreffer ">runtime.growslice</a></p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片容量小于 1024 就会将容量翻倍；</li>
<li>如果当前切片容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<h3 id="哈希表">哈希表</h3>
<h4 id="哈希函数">哈希函数</h4>
<h4 id="冲突解决方法">冲突解决方法</h4>
<p>开放寻址法和拉链法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[hmap](https://github.com/golang/go/blob/ed15e82413c7b16e21a493f5a647f68b46e965ee/src/runtime/map.go#L115-L129)
</span></span><span class="line"><span class="cl">type hmap struct {
</span></span><span class="line"><span class="cl">	count     int
</span></span><span class="line"><span class="cl">	flags     uint8
</span></span><span class="line"><span class="cl">	B         uint8
</span></span><span class="line"><span class="cl">	noverflow uint16
</span></span><span class="line"><span class="cl">	hash0     uint32
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	buckets    unsafe.Pointer
</span></span><span class="line"><span class="cl">	oldbuckets unsafe.Pointer
</span></span><span class="line"><span class="cl">	nevacuate  uintptr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	extra *mapextra
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>创建 map</strong></p>
<p><a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L303-L336" target="_blank" rel="noopener noreffer ">runtime.makemap</a></p>
<p>golang 通过拉链法处理冲突</p>
<p><strong>读写</strong>
增加、删除和修改
<a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450" target="_blank" rel="noopener noreffer ">mapaccess1</a></p>
<p>扩容（不是原子操作）</p>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L685-L791" target="_blank" rel="noopener noreffer ">runtime.mapdelete</a></p>
<p>Go 语言使用拉链法来解决哈希碰撞的问题实现了哈希表，它的访问、写入和删除等操作都在编译期间转换成了运行时的函数或者方法。</p>
<p>哈希在每一个桶中存储键对应哈希的前 8 位，当对哈希进行操作时，这些 tophash 就成为了一级缓存帮助哈希快速遍历桶中元素，每一个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会被存储到哈希的溢出桶中。</p>
<p>随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。</p>
<h3 id="字符串">字符串</h3>
<p><a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener noreffer ">十分钟搞清字符集和字符编码</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StringHeader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Len</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">stringStruct</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">str</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">len</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/golang/go/blob/b6feb03b24a75164438c3419c0bc01fef62825a0/src/runtime/string.go#L80" target="_blank" rel="noopener noreffer ">slicebytetostring</a></p>
<h2 id="oo">OO</h2>
<h3 id="函数调用">函数调用</h3>
<p>C 语言和 Go 语言在设计函数的调用惯例时选择也不同的实现。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。我们可以对比一下这两种设计的优点和缺点：</p>
<ol>
<li>C 语言的方式能够减少大量小函数调用的开销，但是也增加了实现的复杂度；
<ul>
<li>CPU 访问栈(内存)的开销比<a href="https://arstechnica.com/gadgets/2002/07/caching/2/" target="_blank" rel="noopener noreffer ">访问寄存器高几十倍</a>；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
</li>
<li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；
<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间需要在栈上进行分配；</li>
</ul>
</li>
</ol>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p>
<h4 id="参数传递">参数传递</h4>
<p>golang 无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</p>
<h3 id="接口">接口</h3>
<p>类型转换、类型断言以及动态派发机制</p>
<p>iface 结构体 是带有一组方法的接口
eface 结构体 不带任何方法的 interface{}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type eface struct { // 16 bytes
</span></span><span class="line"><span class="cl">	_type *_type
</span></span><span class="line"><span class="cl">	data  unsafe.Pointer
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type iface struct { // 16 bytes
</span></span><span class="line"><span class="cl">	tab  *itab
</span></span><span class="line"><span class="cl">	data unsafe.Pointer
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>动态派发的过程只是放大了参数拷贝带来的影响, 用结构体实现接口会有更多消耗(125%)</p>
<h3 id="反射">反射</h3>
<h2 id="常用关键字">常用关键字</h2>
<h3 id="for-和-range">for 和 range</h3>
<p>一些 golang buildin func 是由原始的汇编写成，比如<a href="https://github.com/golang/go/blob/05c02444eb2d8b8d3ecd949c4308d8e2323ae087/src/runtime/memclr_386.s#L12-L16" target="_blank" rel="noopener noreffer ">runtime·memclrNoHeapPointers</a></p>
<h3 id="select">select</h3>
<p>当 select 中的两个 case 同时被触发时，就会随机选择一个 case 执行。</p>
<ol>
<li>select 能在 Channel 上进行非阻塞的收发操作；</li>
<li>select 在遇到多个 Channel 同时响应时会随机挑选 case 执行；(如果我们按照顺序依次判断，那么后面的条件永远都会得不到执行，而随机的引入就是为了避免饥饿问题的发生)</li>
</ol>
<p>非阻塞的收发:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select {
</span></span><span class="line"><span class="cl">case err := &lt;-errCh:
</span></span><span class="line"><span class="cl">    return err
</span></span><span class="line"><span class="cl">default:
</span></span><span class="line"><span class="cl">    return nil
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="noopener noreffer ">scase</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type scase struct {
</span></span><span class="line"><span class="cl">	c           *hchan         // chan
</span></span><span class="line"><span class="cl">	elem        unsafe.Pointer // data element
</span></span><span class="line"><span class="cl">	kind        uint16
</span></span><span class="line"><span class="cl">	pc          uintptr // race pc (for race detector / msan)
</span></span><span class="line"><span class="cl">	releasetime int64
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="defer">defer</h3>
<h3 id="panic-和-recover">panic 和 recover</h3>
<p><a href="https://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover" target="_blank" rel="noopener noreffer ">Defer, Panic, and Recover</a></p>
<ol>
<li>
<p>panic 只会触发当前 Goroutine 的延迟函数调用；</p>
</li>
<li>
<p>recover 只有在 defer 函数中调用才会生效；</p>
</li>
<li>
<p>panic 允许在 defer 中嵌套多次调用；</p>
</li>
<li>
<p>跨协程失效 首先要展示的例子就是 panic 只会触发当前 Goroutine 的延迟函数调用</p>
</li>
</ol>
<p>多个 Goroutine 之间没有太多的关联
<a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="noopener noreffer ">runtime._panic</a></p>
<h3 id="总结">总结</h3>
<ol>
<li>编译器会负责做转换关键字的工作；
<ul>
<li>将 panic 和 recover 分别转换成 runtime.gopanic 和 runtime.gorecover；</li>
<li>将 defer 转换成 deferproc 函数；</li>
<li>在调用 defer 的函数末尾调用 deferreturn 函数；</li>
</ul>
</li>
<li>在运行过程中遇到 gopanic 方法时，会从 Goroutine 的链表依次取出 _defer 结构体并执行；</li>
<li>如果调用延迟执行函数时遇到了 gorecover 就会将 _panic.recovered 标记成 true 并返回 panic 的参数；
<ul>
<li>在这次调用结束之后，gopanic 会从 _defer 结构体中取出程序计数器 pc 和栈指针 sp 并调用 recovery 函数进行恢复程序；</li>
<li>recovery 会根据传入的 pc 和 sp 跳转回 deferproc；</li>
<li>编译器自动生成的代码会发现 deferproc 的返回值不为 0，这时会跳回 deferreturn 并恢复到正常的执行流程；</li>
</ul>
</li>
<li>如果没有遇到 gorecover 就会依次遍历所有的 _defer 结构，并在最后调用 fatalpanic 中止程序、打印 panic 的参数并返回错误码 2；</li>
</ol>
<h3 id="make-和-new">make 和 new</h3>
<p>make 关键字的作用是创建切片、哈希表和 Channel 等内置的数据结构，而 new 的作用是为类型申请一片内存空间，并返回指向这片内存的指针。</p>
<h2 id="运行时">运行时</h2>
<h3 id="并发">并发</h3>
<h4 id="上下文-context">上下文 Context</h4>
<ol>
<li>Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期；</li>
<li>Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个 Channel；</li>
<li>Err — 返回 context.Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值；
<ol>
<li>如果 context.Context 被取消，会返回 Canceled 错误；</li>
<li>如果 context.Context 超时，会返回 DeadlineExceeded 错误；</li>
</ol>
</li>
<li>Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；</li>
</ol>
<p><a href="https://blog.golang.org/context" target="_blank" rel="noopener noreffer ">Go Concurrency Patterns: Context</a></p>
<h4 id="同步原语与锁">同步原语与锁</h4>
<p>Mutex、RWMutes、WaitGroup、Once x/sync/errgroup.Group、x/sync/semaphore.Weighted、x/sync/singleflight.Group 和 x/sync/syncmap.Map</p>
<p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="noopener noreffer ">sync.Mutex</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Mutex struct {
</span></span><span class="line"><span class="cl">	state int32
</span></span><span class="line"><span class="cl">	sema  uint32
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>正常模式 =&gt; 在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』。
饥饿模式 =&gt; 在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。</p>
<p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p>
<p>Go 语言还在子仓库 sync 中提供了四种扩展原语，x/sync/errgroup.Group、x/sync/semaphore.Weighted、x/sync/singleflight.Group 和 x/sync/syncmap.Map，其中的 x/sync/syncmap.Map 在 1.9 版本中被移植到了标准库中。</p>
<h4 id="定时器">定时器</h4>
<p>而在 10ms 的这个粒度下，作者在社区中也没有找到能够使用的计时器实现，一些使用时间轮算法的开源库也不能很好地完成这个任务。</p>
<h4 id="channel">Channel</h4>
<p>创建、发送、接收和关闭
不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存
CSP
无锁（lock-free）队列更准确的描述是使用乐观并发控制的队列
<a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="noopener noreffer ">runtime.hchan</a></p>
<p><a href="http://people.cs.pitt.edu/~jacklange/teaching/cs2510-f12/papers/implementing_lock_free.pdf" target="_blank" rel="noopener noreffer ">impl lock free 论文</a>
<a href="https://github.com/OneOfOne/lfchan" target="_blank" rel="noopener noreffer ">社区 lock free chan</a></p>
<p><strong>send</strong>
<a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L126" target="_blank" rel="noopener noreffer ">runtime.chansend1</a></p>
<ol>
<li>当存在等待的接收者时，通过 runtime.send 直接将数据发送给阻塞的接收者；</li>
<li>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；</li>
<li>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；</li>
</ol>
<p><strong>recv</strong></p>
<ol>
<li>如果 Channel 为空，那么就会直接调用 runtime.gopark 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 函数会直接返回；</li>
<li>如果 Channel 的 sendq 队列中存在挂起的 Goroutine，就会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据就会直接读取 recvx 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<h4 id="调度器">调度器</h4>
<p>每一次线程上下文的切换都需要消耗 ~1us 左右的时间：<a href="https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/" target="_blank" rel="noopener noreffer ">Measuring context switching and memory overheads for Linux threads</a>
Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销</p>
<h4 id="网络轮询器">网络轮询器</h4>
<h4 id="系统监控">系统监控</h4>
<h3 id="内存管理">内存管理</h3>
<h4 id="内存分配器">内存分配器</h4>
<p>TCMalloc
隔离适应</p>
<h4 id="垃圾收集器">垃圾收集器</h4>
<p>标记清除</p>
<p>三色抽象</p>
<ol>
<li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li>
<li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li>
<li>重复上述两个步骤直到对象图中不存在灰色对象；</li>
</ol>
<p>屏障技术</p>
<h4 id="栈内存管理">栈内存管理</h4>
<h2 id="其他">其他</h2>
<h3 id="unsafe">unsafe</h3>
<h3 id="逃逸分析">逃逸分析</h3>
<h2 id="build-comment">build comment</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//go:nosplit
</span></span><span class="line"><span class="cl">//go:linkname
</span></span><span class="line"><span class="cl">//go:noescape
</span></span><span class="line"><span class="cl">//go:notinheap
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*(*int)(nil) = 0 // not reached
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="reference">reference</h2></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-01-27&nbsp;<a class="git-hash" href="https://github.com/exfly/HugoBlog/commit/bbce58a8aef682eeae15cb251ddac0c2ca595768" target="_blank" title="commit by exfly(exflyg@gmail.com) bbce58a8aef682eeae15cb251ddac0c2ca595768: refactor: rename all simple posts">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>bbce58a</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://exfly.github.io/go-compiler-overview/" data-title="Go Overview"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://exfly.github.io/go-compiler-overview/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://exfly.github.io/go-compiler-overview/" data-title="Go Overview"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://exfly.github.io/go-compiler-overview/" data-title="Go Overview"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://exfly.github.io/go-compiler-overview/" data-title="Go Overview"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/opentracing-jaeger-agent-src-code-introduce/" class="prev" rel="prev" title="Opentracing - jaeger 源码分析"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Opentracing - jaeger 源码分析</a>
            <a href="/go-runtime-fatal-sigsegv-during-c.getaddrinfo/" class="next" rel="next" title="golang runtime: fatal error: SIGSEGV during C.getaddrinfo">golang runtime: fatal error: SIGSEGV during C.getaddrinfo<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="giscus" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://giscus.app">Giscus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.122.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/exfly/" target="_blank">exfly</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{"giscus":{"category":"Announcements","categoryId":"DIC_kwDOBCuJFs4CT0-J","darkTheme":"dark","emitMetadata":"0","inputPosition":"top","lang":"zh-CN","lazyLoading":false,"lightTheme":"light","mapping":"pathname","reactionsEnabled":"1","repo":"exfly/exfly.github.io","repoId":"MDEwOlJlcG9zaXRvcnk2OTk2MjAwNg=="}},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.zh-cn","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-6XWGXY4X6W', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-6XWGXY4X6W" async></script></body>
</html>
